<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>chess.mw</title>
    <style type="text/css">
      canvas {
        border: 1px solid black;
      }
    </style>
  </head>
  <body>
    <canvas id="Canvas" width="800" height="800"></canvas>
  </body>
  <script>
    const X = 8;
    const Y = 8;
    const Width = 100;
    const Height = 100;
    const MaxWidth = Width * X;
    const MaxHeight = Height * Y;
    const indexs = {
      pawn: 0,
      rook: 1,
      knight: 2,
      bishop: 3,
      queen: 4,
      king: 5,
    };
    const positions = [0, 0, 1, 2, 3, 4];
    const names = ["pawn", "rook", "knight", "bishop", "queen", "king"];
    const images = {};
  </script>

  <script>
    function isValidCord(x, y, isWhite) {
      // ouf of bound 0
      // enemy 1
      // empty 2
      if (x < 0 || x >= X || y < 0 || y >= Y) {
        return 0;
      } else if (board.squares[y][x].piece) {
        if (board.squares[y][x].piece.isWhite == isWhite) {
          return 0;
        } else {
          return 1;
        }
      } else {
        return 2;
      }
    }

    function pawn(x, y, isWhite) {
      var result = [];
      var _x, _y, dx, dy;
      if (isWhite) {
        dx = -1;
        dy = -1;
      } else {
        dx = 1;
        dy = 1;
      }

      // first 2 step
      _x = x;
      _y = y + 2 * dy;
      if (isValidCord(_x, _y, isWhite) == 2) {
        result.push({ x: _x, y: _y });
      }

      // normal
      _x = x;
      _y = y + dy;
      if (isValidCord(_x, _y, isWhite) == 2) {
        result.push({ x: _x, y: _y });
      }

      // kill
      _x = x + dx;
      _y = y + dy;
      if (isValidCord(_x, _y) == 1) {
        result.push({ x: _x, y: _y });
      }

      _x = x - dx;
      _y = y + dy;
      if (isValidCord(_x, _y) == 1) {
        result.push({ x: _x, y: _y });
      }

      return result;
    }

    const availFunctions = {
      pawn: pawn,
    };
  </script>

  <script>
    function loadImage(key, src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          images[key] = img;
          resolve(img);
        };
        img.onerror = reject;
        img.src = src;
      });
    }

    async function loadImages(ext) {
      const imagePromises = names.map(async (name) => {
        const src = "./chessElement/" + name + ext;
        await loadImage(name, src);
      });

      return Promise.all(imagePromises);
    }
  </script>

  <script>
    class Square {
      constructor(x, y, isWhite) {
        this.x = x;
        this.y = y;
        this.isWhite = isWhite;
        this.colorScript = isWhite
          ? "rgba(115, 0, 0, 1)"
          : "rgba(0, 115, 0, 1)";
      }

      fill() {
        ctx.fillStyle = this.colorScript;
        ctx.fillRect(this.x * Width, this.y * Height, Width, Height);
      }
    }
  </script>

  <script>
    class Piece {
      constructor(x, y, sort, isWhite, ctx) {
        this.x = x;
        this.y = y;
        this.sort = sort;
        this.isWhite = isWhite;
        this.ctx = ctx;
        this.avail = [];
      }

      fill() {
        this.ctx.drawImage(
          images[this.sort],
          this.x * Width,
          this.y * Height,
          Width,
          Height
        );
      }

      updateAvail(whiteTurn) {
        return (this.avail =
          this.isWhite == board.whiteTurn
            ? availFunctions[this.sort](this.x, this.y, this.isWhite)
            : []);
      }
    }
  </script>

  <script>
    class Board {
      constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.whiteTurn = true;
        this.squares = [];
        for (var y = 0; y < Y; ++y) {
          this.squares.push([]);
          for (var x = 0; x < X; ++x) {
            this.squares[y].push(new Square(x, y, (x + y) % 2));
          }
        }
      }

      fill() {
        for (var y = 0; y < Y; ++y) {
          for (var x = 0; x < X; ++x) {
            this.squares[y][x].fill();
            if (this.squares[y][x].piece) {
              this.squares[y][x].piece.fill(x, y);
            }
          }
        }
      }

      makePieces() {
        //white
        this.makeKQRNB(0, false);
        this.makePawns(1, false);

        //black
        this.makePawns(Y - 2, true);
        this.makeKQRNB(Y - 1, true);
      }

      makePawns(y, isWhite) {
        for (var x = 0; x < X; ++x) {
          this.squares[y][x].piece = new Piece(
            x,
            y,
            names[indexs.pawn],
            isWhite,
            this.ctx
          );
        }
      }

      makeKQRNB(y, isWhite) {
        var x;
        for (var idx = 1; idx < 4; ++idx) {
          x = positions[idx];
          this.squares[y][x].piece = new Piece(
            x,
            y,
            names[idx],
            isWhite,
            this.ctx
          );

          x = X - 1 - positions[idx];
          this.squares[y][x].piece = new Piece(
            x,
            y,
            names[idx],
            isWhite,
            this.ctx
          );
        }

        for (var idx = 4; idx < 6; ++idx) {
          x = positions[idx];
          this.squares[y][x].piece = new Piece(
            x,
            y,
            names[idx],
            isWhite,
            this.ctx
          );
        }
      }

      setMouseClick() {
        this.canvas.onclick = (event) => {
          const _x = Math.trunc(event.clientX / Width);
          const _y = Math.trunc(event.clientY / Height);

          console.log(board.squares[_y][_x].piece.updateAvail(this.whiteTurn));
        };
      }
    }
  </script>

  <script>
    const canvas = document.getElementById("Canvas");
    const ctx = canvas.getContext("2d");
    const board = new Board(canvas, ctx);
    loadImages(".svg").then(() => {
      console.log("images loaded...");
      board.makePieces();
      board.fill();
      board.setMouseClick();
    });
  </script>
</html>
